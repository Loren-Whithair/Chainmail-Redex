Loo vs Javalite: notes, comparisons


NOTES, NEXT STEPS, QUESTIONS
--------------------------------

Modules need defining in the grammar (potentially can be similar in structure to Javalite in some regards)

In the paper, Loo has a definition of field and class lookup, but it is not grammatically defined.
We will need to add a gramatical definition so that we can use it in reductions.

Loo has a method, ghostfield, and constructor lookup.

Reductions of a state of Loo will be over #:domain σ    (runtime configs)

In Loo, the local scope is managed by ϕ (Frame). Instead of having a list of local vars that needs mutating, the vars are assosciated with the frame, new frames are added to the stack
when we begin execution of a new method call, expr etc.

Do we only need expression (e) for ghost functions, nothing else (...?)

  
  
    OPERATIONAL SEMANTICS COMPARISON
elem      | Loo          | Javalite
----------|--------------|----------
frame     | ϕ            | part of state (similar): (η + e)
stack     | ψ            | (managed by state, not explicitly an element)
heap      | χ            | h
contin.   | Continuation | k (but defn. in Loo paper is much less detailed than Javalite) 
class list| (MODULE)     | μ   

    
    
    
  ------------------------------------
  ----------------Loo-----------------
  ------------------------------------


(define-language Loo

  (ClassDesc ::= (class C(x ...) { (FieldDecl) ... (CDecl)? (MethDecl) ... (GhostDecl) ... }))
  (FieldDecl ::= (field f))
  (CDecl ::= (constructor(x ...) { Stmts }))
  (MethDecl ::= (method m(x ...) { Stmts }))
  (Stmts ::= Stmt
             (Stmt $ Stmts))
  (Stmt ::= (x @ f := x)
            (x := x @ f)
            (x := x @ m(x ...))
            (x := new C(x ...))
            (return x))
  (GhostDecl ::= ghost f(x ...) { e })    ;; MISSING FROM JAVALITE
  (e ::= true
         false
         null
         x
         (e = e)
         (if e then e else e)
         (e @ f(e ...)))

  (x ::=      ;; VarID  (variable name)
     this
     id)
  (C ::= id)  ;; ClassID (class name)
  (f ::= id)  ;; FieldID (field name)
  (m ::= id)  ;; MethID  (method name)

  (id ::= variable-not-otherwise-mentioned))

  
  
(define-extended-language Loo-Machine Loo
  (addr ::= natural)  ;;addresses
  (v ::=    ;;values
     null
     addr
     (addr ...))
  (Object ::= (ClassID (f -> v) ...))

  (Continuation ::=   ;;Continuation ;;TODO: may need more continuation definitions
     Stmts
     (x := * $ Stmts))
  (ϕ ::= (CodeStub ((ident -> v) ...)))  ;; Frame   (TODO: idenfitiers?)
  (ψ ::=  ϕ  (ϕ · ψ))  ; --------------- ;; Stack
  (χ ::= ((addr -> Object) ...)) ; ----- ;; heap
  (σ ::= (ψ · χ)))  ; ------------------ ;; runtime config
  
  

  ;;;;;;;;;;;;
  
       

  ------------------------------------
  --------------JAVALITE--------------
  ------------------------------------
  
  (define-language Javalite
  (P ::= (μ (C m)))
  (μ ::= (CL ...))   ;; class list   ;;Loo modules? Would need the concept of multiple separate modules
  (T ::=  ;; types   ;; NOT IN LOO
     bool   
     unit
     C)

  (CL ::= (class C extends C ([T f] ...) (M ...)))  ;; class declaration == Loo ClassDesc. very similar, ?no extensions in Loo?
  (M ::= (T m ([T x] ...) e))   ; ----------------- ;; method decl == Loo MethDecl. very similar
 
 (e ::=      ;; ~~ Loo (Stmt + e)
     x       ;; in Loo e
     v       ;; in Loo e (true false null)
     (new C) ;; in Loo Stmt (x := new C(x ...))

     (e $ f) ; ---------- ;; field access ~~ Loo Stmt (x := x @ f)
     (e @ m (e ...)) ; -- ;; method invocation ~~ Loo Stmt (x := x @ m(x...))
     (e == e)  ; -------- ;; equality == Loo e (e = e)
     (C e)  ; ----------- ;; typecast ;; TYPES NOT IN LOO
     (e instanceof C) ; - ;; TYPES NOT IN LOO
     (x := e)  ; -------- ;; ~~ Loo Stmt
     (x $ f := e) ; ----- ;; field setting
     (if e e else e)  ; - ;; == e (if e then e else e)
     (var T x := e in e)  ;; var declaration
     (begin e ...)) ; --- ;; a block of code

  
  (x ::= this id) ; ----- ;; in Loo (x)
  (f ::= id)  ; --------- ;; in Loo (f)
  (m ::= id)  ; --------- ;; in Loo (m)
  (C ::= Object id)  ; -- ;;
  
  (id ::= variable-not-otherwise-mentioned)
  
  (pointer ::= (addr loc C) null)
  
  (v ::= ;; part of Loo e
     pointer
     true
     false
     unit
     error)  ;; variable
  (loc ::= number))   ;; numeric location in heap  ;;not in basic Loo, but will be needed
  
